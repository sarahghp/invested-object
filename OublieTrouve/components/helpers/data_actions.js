import React, { Component } from 'react';

import Native, {
  StyleSheet,
  Text,
  TextInput, 
  TouchableHighlight,
  View
} from 'react-native';

import update               from 'react-addons-update';
import SimpleStore          from 'react-native-simple-store';
import events               from '../Events';
import DetailView           from '../Detail';
import BaseMoment           from './base_moment';
import { tests, conxList }  from './conx';
import _                    from 'lodash';


// Helper function to create simple conx
const _populateMembers = function(moment, cxList, testList, addMoment){

  _.each(cxList, function(category){

    // Have to do it this way becasue JSON won't let us save functions
    let test = testList[category.type][category.modifier];

    if (test(moment)){
      addMoment && category.members.unshift(moment);
      
      moment.conx.push({
        type: category.type,
        modifier: category.modifier,
        imageTitle: category.imageTitle,
      });
    }

  });
}

// Helper function to create complex conx

const _complexConx = function(list){
  
  let complexes = [
    ['Weather'],
    ['Distance From Home', 'Elevation'],
    ['Distance From Home', 'Weather'],
    ['Time of Day', 'Temp'],
    ['Temp', 'Humidity', 'Weather'],
  ];

  let getOne = function(a){
    return _.map(a, (first) => {
                  return {
                    type: 'Compound',
                    modifier: first.modifier,
                    members: first.members,
                    images: [first.imageTitle],
                  } 
                });
  }

  let getTwo = function([a, b]){
    let flat = _.flatten(_.map(a, (first) => {
      return _.map(b, (second) => {
        let intersected = _.intersectionBy(first.members, second.members, 'title');
        return { 
          type: 'Compound',
          modifier: first.modifier + '-' + second.modifier, 
          members: intersected,
          images: [first.imageTitle, second.imageTitle],
        }
      })
    }));

    return _.filter(flat, (f) => f.members.length > 0);
  }

  let getThree = function([a, b, c]) {
    let flat = _.flatten(_.map(a, (first) => {
      return _.flatten(_.map(b, (second) => {
        return _.map(c, (third) => {
          let intersected = _.intersectionBy(first.members, second.members, third.members, 'title');
          return { 
            type: 'Compound',
            modifier: first.modifier + '-' + second.modifier + '-' + third.modifier, 
            members: intersected,
            images: [first.imageTitle, second.imageTitle, third.imageTitle],
          }
        })
      }))
    }))

    return _.filter(flat, (f) => f.members.length > 0);
  }

  let test = _.map(complexes, (complex) => {

    let to;
    let name = complex.join('-');
    let members = _.map(complex, (c) => _.filter(list, { type: c }));

    if (complex.length === 1){
      let flat = _.flatten(members);
      to = getOne(flat);
    } else if (complex.length === 2){
      to = getTwo(members);
    } else if (complex.length === 3){
      to = getThree(members);
    }
    
    return to;


  });

  // console.log('test', _.flatten(test));
  return _.flatten(test);

}

// Adds new moment, whether generated by form or button
const _addToStore = function() {

  // how should this function if called from position
  let newEntry = this.state ? Object.assign(new BaseMoment(), _.cloneDeep(this.state.details)) : new BaseMoment();

  Promise.all([newEntry.populate(), SimpleStore.get('all_moments')])
    .then(values => {
      // set ID now that we have the data length
      let data = values[1];
      newEntry.id = data.length;
      return data;
    })
    .then((data) => {
      data.unshift(newEntry);
      SimpleStore.save('all_moments', data);
    })
    .then(() => SimpleStore.get('all_conx'))
    .then((data) => {
      _populateMembers(newEntry, data, tests, true);
      SimpleStore.save('all_conx', data);
      events.emit('refreshData');
    })
    .then(() => SimpleStore.get('all_moments'))
    .then((data) => {
      console.log('gotten', data[0]);
    })
    .catch(error => {
      console.error(error.message);
    });
}

const _saveToStore = function(){
    let idx;

    SimpleStore.get('all_moments')
    .then((data) => {
       idx = _.findIndex(data, { id: this.props.details.id });
       data[idx].title = this.state.details.title;
       data[idx].description = this.state.details.description;
       SimpleStore.save('all_moments', data);
       events.emit('refreshData');
    })
    .then(() => SimpleStore.get('all_moments'))
    .then((data) => {
      console.log('gotten', data[idx]);
    })
    .catch(error => {
      console.error(error.message);
    });
  }

const _updateDetailState = function(text, updateMe){
  let newDetail = update(this.state.details, {$merge: {[updateMe]: text} });
  this.setState({details: newDetail});
}

const _checkForConx = function(navigator, threshold){
  
  let go = Math.random() > threshold;

  if (go) {
    let thisMoment = new BaseMoment();

    thisMoment.populate()
      .then(() => SimpleStore.get('all_conx'))
      .then((data) => {
        _populateMembers(thisMoment, data, tests, false);
        
        let collection = _.sample(thisMoment.conx),
            cx         = _.find(data, {type: collection.type, modifier: collection.modifier});
        
        if (cx.members.length > 0){
          Native.NativeModules.Bean.buzzBean();

          // Prevent a stack from accumulating
          let method = navigator.getCurrentRoutes().length === 1 ? 'push' : 'replace'; 
          navigator[method]({
            name: 'Detail',
            component: DetailView,
            passProps: {
              navigator: navigator,
              title: collection.type + ': ' + collection.modifier,
              detailKind: 'list',
              filter: collection.modifier,
            }
          });
        }

      })
      .catch(error => {
        console.error(error.message);
      });
  }


  // show the conx as the default app page
}

export {_addToStore, _saveToStore, _updateDetailState, _populateMembers, _checkForConx, _complexConx }